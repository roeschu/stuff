#########################################
#- Zeitvariablen und Funktionen
#########################################
chomp($dayofbackup = (Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)[(localtime)[6]]);
my ($hh,$mm,$ss,$tag,$mo,$jahr)=(localtime(time)) [2,1,0,3,4,5];
my $zeit=time;
my $tim = sprintf('%02d:%02d:%02d',$hh,$mm,$ss);
my $jahrr=($jahr-100)+2000;
my $tagg = sprintf('%02d',$tag);
my $mor=($mo+1);
my $morr=sprintf('%02d',$mor);
my $datum= $jahrr.$morr.$tagg;
#########################################

---------------------------------------------------------------------------------------------------------

#########################################
#- whois query mit grepping nach suchtext
#########################################
#!/usr/local/bin/perl -w

open(DAT, "<master.csv") or die "bla";

@csvinhalt = <DAT>;
close(DAT);
chomp(@csvinhalt);




foreach  (@csvinhalt)
{
	$url = (split(/,/, $_)) [0];
	my $whois = "whois";
	my $grep = "grep -i -E '(194.222.22.22|ns1.broweider.net)'";
	my $pipe = ">> /daten/domains/" . $url;
	
 
	my @args = ($whois, $url, $pip, $pipe);

	

	system("@args");
	my $purl = "/daten/domains/" . $url;
        my @args1 = ($grep, $purl);
	
	$debug = system("@args1");
	if (system("@args1")=="0")
	{
		open(GOOD,">>/daten/GOODDOMAINS.txt");	
		print GOOD $url . "\n";
		close(GOOD);
	}
	else
	{
		open(BAD,">>/daten/BADDOMAINS.txt");
		print BAD $url . "\n";
		close(BAD);
	}
 	
	print $url . "\n";
		
	sleep 30;


}


close(DAT);

#########################################

---------------------------------------------------------------------------------------------------------

#########################################
#- files welche älter als 1 stunde sind
#########################################
	if (-e $folder . $element)
	{
		$now = time;
		@fileinfo = stat $folder . $element;

		if ($fileinfo[9] + 3600 < $now )
.....
		
#########################################



---------------------------------------------------------------------------------------------------------


#########################################
#- pc über ssh runterfahren
#- braucht NET::SSH::PERL modul#
#########################################
my $ssh = Net::SSH::Perl->new($host);
$ssh->login($user, $pass);
my ($stdout, $stderr, $exit) = $ssh->cmd($cmd);

if ($exit == 0)
{
	open(LOGHANDLE,">> $actionlogpath$actionlogname");
	print LOGHANDLE $datum . " " . $tim . "   " . "$server wurde heruntergefahren\n";
	close (LOGHANDLE);		
}
else
{
	open(LOGHANDLE,">> $actionlogpath$actionlogname");
	print LOGHANDLE $datum . " " . $tim . "   " . "Probleme beim herunterfahren von $server\n";
	close (LOGHANDLE);
	
}
#########################################


---------------------------------------------------------------------------------------------------------

#########################################
#- liest dirinhalt aus 
#- sortiert array mit jüngster datei zuoberst
#- stat, sort
#########################################
#!/usr/bin/perl -w

#Verzeichnis welches ausgelesen werden soll
my $folder = '/perlteschts/';


# Verzeichnis oeffnen
opendir (VERZEICHNISHANDLE,$folder);

# Ins Array werden alle Dateien im Verzeichnis eingelesen aussert "." und ".."
if (@verzeichnisinhalt = grep { ! /^\.\.?/ } readdir VERZEICHNISHANDLE)
{
	
	# sort sortiert das Array nach Aenderungsdatum (nicht Erstellungsdatum...) der Dateien,
	# somit ist der erste Wert im Array die Datei welche zuletzt geändert wurde, wenn du
	# die Datei mit dem ältesten Aenderungsdatum willst einfach $b und $a vertauschen...
	@verzeichnisinhalt = sort { (stat "$folder/$b")[9] <=> (stat "$folder/$a")[9] } @verzeichnisinhalt;
	my $juengstes = $verzeichnisinhalt[0];
	print $juengstes . "\n";
	

	closedir(VERZEICHNISHANDLE);
	
}
else
{

	exit;

}
#########################################


---------------------------------------------------------------------------------------------------------

#########################################
#- Log schreiben oder mailen
#- loglevel
#########################################
sub writeLog ($$)
{
	
#Es wird die Subroutine createlogfile() aufgerufen	
createlogfile();

#Die mitgegebenen Parameter (writeLog(parameter1,parameter2)
#werden aufgefangen
my $logmessage = shift;
my $loglevel = shift;

#Je nach Loglevel wird die Loginfo gesetzt (erscheint in der
#Logdatei).
if ($loglevel == 10) { $loginfo = "ERROR"; }
if ($loglevel == 20) { $loginfo = "WARNUNG";	     }
if ($loglevel == 30) { $loginfo = "INFORMATION";    }

#Es wird ins Logfile geschrieben
open(LOGHANDLE,">> $logpath$logname");
print LOGHANDLE $datum . " " . $tim . "  " . $loginfo . ": " . $logmessage . "\n";
close (LOGHANDLE);	

#Falls der Loglevel 10 ist (ERROR) wird ein E-mail an den Admin
#versendet ($adminaccount)
	if ($loglevel eq 10)
	{
		open (MAIL, "|$mailer -t ") || die "Email error";
		print MAIL "From: Nsync Logwatch  <youareaidiot\@gmx.ch>\n";
		print MAIL "To: $adminmail\n";
		print MAIL "Subject: ERROR beim Scriptlauf nsync.p\n\n";
		print MAIL "Hallo \n\nERRORSTRING:\n********************\n";
		print MAIL "$logmessage\n********************\n\n";
		print MAIL "Weitere Infos findet man eventuell im Logfile: $logpath . $logname\n\n";
		print MAIL "Freundliche Gruesse\n\nnsync.pl logwatch";
		close (MAIL);
	
	}#END IF
	

}#END SUB
#########################################



---------------------------------------------------------------------------------------------------------

#########################################
#- Export von vars und funktionen aus modul
#########################################
require Exporter;
use vars qw(@ISA @EXPORT);
use Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(writeLog creatlogfile @args $mkdir $logpath $logname $zeit $tim $jahrr $tagg $mor $morr $datum $loginfo $logmessages $loglevel);

#########################################


---------------------------------------------------------------------------------------------------------

#########################################
#- ssh + scp benutzung
#########################################

#!/usr/bin/perl -w
#use strict;
use Net::SCP;
use Net::SSH qw(sshopen2);


my $folder = "/scptest";
my $user = "rocky";
my $host = "192.168.3.102";
my $cmd = "ls " . $folder . " >> /scptest/Zones";


sshopen2("$user\@$host", *READER, *WRITER, $cmd) || die "ssh: $!";

while (<READER>) 
{

#	opendir (VERZ,$folder);
#	@verzinhalt = readdir VERZ;
	#closedir (VERZ);
	#print @verzinhalt;

	

}

close (READER);
close (WRITER);
#########################################



--------------------------------------------------------------------------------------------------------

#########################################
#- ssh + scp benutzung
#########################################
#!/usr/bin/perl -w
use Net::SCP;
#use Net::SSH qw(sshopen2);

$scp = Net::SCP->new( "192.168.3.102", "rocky");

#$scp->scp("/home/rocky", "/scptest") or die $scp->{errstr};



$scp->get("/scptest") or die $scp->{errstr};
#########################################


---------------------------------------------------------------------------------------------------------

#########################################
#- dns query
#########################################
#!/usr/bin/perl -w
use Net::DNS;

my $resolv = Net::DNS::Resolver->new;
my @mx = mx($resolv, "garage-schlauriag.ch");


if (@mx) {
	foreach $rr (@mx)
	{
		print $rr->preference, " ", $rr->exchange, "\n";

	}


}
#########################################

---------------------------------------------------------------------------------------------------------

#########################################
#- Scriptparameter auswerten
#########################################
use Getopt::Std;
getopts('h');
# Check if help was choosen. If yes, display help and exit
sub checkCommandLineArguments 
{
	if ($opt_h)
 	{
 	print $help;
 	exit 1;
 	}
 	
}
# End sub
#########################################
--------------------------------------------------------------------------------------------------------






#########################################
#- Mail verschicken
#########################################

		if (! (-e $rsync_verzeichnis . $url))
		{					
			
			 
			 
			open (MAIL, "|$mailer -t ") || die "Email error";
			print MAIL "From: Interner DNS  <we-take-care\@goolemail.com>\n";
			print MAIL "To: $account\n";
			print MAIL "Subject: $url Zone auf internem DNS $hostname\n\n";
			print MAIL "Hallo \n\nDie $url Zonendatei existiert auf dem internen DNS, jedoch nicht auf";
			print MAIL " dem Secondary DNS. Die Zone sollte wahrscheinlich gelöscht werden.\n";
			print MAIL "\nPfad: $forwardzonen_verzeichnis$url\n\nMFG Dein DNS BOT\n\n\n";
			close (MAIL);
		
		}
		else
		{
			print "no";
		
		}
#########################################



---------------------------------------------------------------------------------------------------------

#########################################
#- dns mx record query + diverses
#- benötigt Net::DNS; DNS::ZoneParse;
#########################################
sub do_query
{

	opendir(STATICHANDLE,$staticzonen_verzeichnis);
	if (@staticurls=grep { ! /^\.\.?/ } readdir STATICHANDLE)
	{	
	
		foreach $staticurl (@staticurls)
		{
		@jaba = (split(/\./,$staticurl));
		
		
		
	 	 	
		$domein = $jaba[1] . "." . $jaba[2];
		my $resolv = Net::DNS::Resolver->new;
		my @mx = mx($resolv,$domein );
	 	print $domein . "\n";			
		
			if (@mx) 
			{
			
				print $mx[0]->exchange, "\n";
				my $mailhost = $mx[0]->exchange;			

				my $zonefile = DNS::ZoneParse->new(\$staticzonen_verzeichnis . $staticurl);
				my $mailrecord = $zonefile->mx;
				$mailrecord->[0] = { host => $mailhost, priority => 10, name => '@' };
				open NEWZONE, ">$staticzonen_verzeichnis . $staticurl";
				print NEWZONE $zonefile->output();
				close NEWZONE; 	
			}
			
		} #end foreach
	} #end if
	else
	{
		
		print "file not open";
			
	}
	
	
 }
#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- Macht irgendwas
#- unlink, rename, open, suchen ersetzen
#########################################
sub do_map
{

	
	opendir(SYNCHANDLE,$rsync_verzeichnis);
	if (@syncurls=grep { ! /^\.\.?/ } readdir SYNCHANDLE)
	{
		
		open(DAT, "<$mapfile") or die "kann csv file nicht oeffnen";
		@csvinhalt = <DAT>;
		close(DAT);
		chomp(@csvinhalt);
		
			
			foreach (@csvinhalt)
			{
			
				($externIP, $internIP,) = (split(/;/, $_)) [0,1];
				foreach $syncurl (@syncurls)
				{
						
				$zonendatei = $rsync_verzeichnis . $syncurl;
				$tmp_file = $tmp_verzeichnis . $syncurl . ".tmp";
				rename $zonendatei, $tmp_file;	
				open ZONENDATEI, "> $zonendatei";
				$ARGV[0] = "$tmp_file"; 
				while(<>) 
				{
					 s/$externIP/$internIP/g;

					print ZONENDATEI;
	 
				}
			        
				  unlink($tmp_file);
 
				} #end foreach syncurls	
		 	} # end foreach csvinhalt
 		
		
	} #end if
	else
	{
		return 1;
	} #end else
		
} #end sub
#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- Beispiel für POD Formatierung
#########################################
=pod

=head1 NAME

nsync.pl


=head1 Beschreibung


Dieses Perlscript gleicht den internen DNS Server mit dem Secondary DNS Server
ab. Das Script holt die Zonen des Secondary DNS aus einem temporaeren Verzeichnis.
Die Zonen in diesem temp Verzeichnis werden vom Secondary DNS via "rsync" abgeglichen.

Mit "delete_zones()" prueft das Script ob es auf dem internen Server Zonen gibt welche auf 
dem Secondary nicht existieren. In diesem Fall wird ein Mail an die Kontaktadresse geschickt
mit den Infos der Zone. Das Script löscht aus Sicherheitsgruenden keine Zonen!

Mit "do_map()" prueft das Script fuer jede Zonendatei ob eine externe IP Adresse in eine
interne umgeschrieben werden muss. Dies geschieht anhand einer Mapping Tabelle welche in einem
csv File hinterlegt ist.

Eine genaue Dokumentation des Scripts ist in den internen Unterlagen unter
laufwerk z: einsehbar.

=over


=back


=head1 SCRIPTAUFRUF

nsync.pl [-h help]


=head1 ERSTELLT

2004-10-10 haarscharf@da.ru


=head1 VERSION


=over

=item 2001-10-12 haarscharf@da.ru, do_map() Funktion gemacht

=item 2001-10-15 haarscharf@da.ru, delete_zone() Funktion gemacht

=back


=head1

=head1 FREMDMODULE


=over

=item Getopt::Std;

=item Net::DNS;


=back

=head1

=cut

#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- Erstellt datei wenn sie nicht existiert
#########################################

if (! (-e $converteddir . "/" . "INCOMING." . $monjah . ".csv"))
			{
			my @argvs = ($touch_command,$converteddir . "/" . "INCOMING." . $monjah . ".csv");
		 	system(@argvs);
						 
			}
#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- Anwendung von Split (trenner "\")
#- ergibt:
#  $dateun[0] -> 10
#  $dateun[1] -> 09
#  $dateun[2] -> 2003
#  @dateun -> 3
#########################################
$datum = "10/09/2009";
@dateun = split /\//,$datum;
#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- Beispiele für Regex suche in datensatz
#\A -> Beginne der Zeile
#\s+ mehrere Whitespaces (leerschläge)
#\d eine zahl (0-9)
#\s* genau ein whitespaces (leerschlag)
#\d+ mehrere zahlen (0-9=
###########################################

sub getdate 
{		
#Datum, Uhrzeit und lokale Nummer speichern
		if (/\A\s+(\d\d\/\d\d\/\d\d)\s+(\d\d:\d\d:\d\d)\s+LINE\s*=\s*\d+\s+STN\s*=\s*(\d+)/)
		{
			$datum = $1;
			$zeit = $2;
			$intphone = $3;
			return $datum, $zeit, $intphone;
		}
		else
		{
		#warn "OUT: Kein Datum, Uhrzeit oder interne Nummer in Datensatz:\n$_\n";
		}
}


sub getphone
{

		#Externe Nummer speichern
		if (/\n\s+CALLING NUMBER\s+(\d+)/)
		{
			$extphone = $1;
			return $extphone;
		}
		else
		{
		#warn "OUT: Keine externe Nummer in Datensatz:\n$_\n";
		}


}


sub getmoney
{

		#Kosten speichern
		if (/\n\s+CALL CHARGE\s*=\s*(\d*\.\d+\s*FR.)/)
		{
			$kosten = $1;
			return $kosten;
		}
		else
		{
		#warn "OUT: Keine Kosten in Datensatz:\n$_\n";
		}


}


sub getdurationOUT
{

		#Anrufdauer speichern
		if (/\n(\d\d:\d\d:\d\d)\s+CALL RELEASED/)
		{
			$dauer = $1;
			return $dauer;
		}
		else
		{
		#warn "OUT: Keine Anrufdauer in Datensatz:\n$_\n";
		}


}



sub getdurationIN
{

		#Anrufdauer merken
		if (/\n(\d\d:\d\d:\d\d)\s+(CALL RELEASED|TRANSFERRED)/)
		{
			$dauer = $1;
			$kosten = "0";
			return $dauer, $kosten;
		}
		else
		{
		#warn "IN: Keine Anrufdauer in Datensatz:\n$_\n";

		}



}


##########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- File einlesen mit INPUT_RECORD_SEPARATOR "$/" Datensatztrenner
#- In Datensatz suchen (OUTGOING CALL, INCOMING CALL)
#- funktionen ausführen
##########################################
#Datensatztrenner beim Einlesen
$/ = "\n\n--------";


open(DAT, "<$convfile") or die "Konnte File " . $file2to . " nicht oeffnen!";

while (<DAT>)
{


	#Fang abgehenden Anruf
	if (/OUTGOING CALL/)
	{

		getdate();
		getphone();
		getmoney();
		getdurationOUT();
		writecsvOUT();

	}
	elsif (/INCOMING CALL/)
	{
		

		getdate();
		getphone();
		getdurationIN();
		writecsvIN();
		

	}
}
#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- In file schreiben (anschliessen)
##########################################
open(INDEXHANDLE,">> $indexfile");
print INDEXHANDLE "Hoschi blabla" .  "\n";
close (INDEXHANDLE);

#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- Variablenübergabe bei routine
##########################################
sub raw2csv($$$)
{
my $var1 = shift;
my $var2 = shift;
my $var3 = shift;
}
#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- Verzeichnis öffnen
#- Dateinamen in Array lesen, ohne Ankerpunkte
#- nur bestimmt Dateinamen in Array ($searchstring)
#- file erstellen bei bedarf ($touch_command)
#- csv dateiinhalt in array lesen (@indexcontents)
#- 2 arrays vergleichen und hash returnieren (%diff)
#########################################
	if(opendir(DIRHANDLE,$downloaddir)) 
	{
		my @files = ();
		my @newfiles = ();
		my $searchstring = "Record.";
		my @indexcontents = ();
		my $indexcontent = "";
			
		#Lies alle Dateinamen in ein Array (aussert Ankerpunkte)
		if (@files=grep { ! /^\.\.?/ } readdir DIRHANDLE)
		{
			@newfiles = grep /$searchstring/, @files;
			
						
				 if (! (-e $indexfile))
				 {
					my @argvs = ($touch_command,$indexfile);
					system(@argvs);
				 }					
				

				 	if(open(DAT, "<$indexfile"))
					{
						#schreibe Dateiinhalt von CSV Datei in Array
						@indexcontents = <DAT>;
						close(DAT);
						chomp(@indexcontents);
					}
					

					@diff{ @newfiles } = ();
					s/indexcontents/newfiles/ for @indexcontents;
					delete @diff { @indexcontents };

					
					
					foreach  (keys %diff)
					{
						print $_ . "\n";
						
					}
				

						return %diff;							
	        									
		}
	}
}

#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#- FTP Download, benötigt cpan modul NET::FTP
#- Nur ftp files holen welche $searchstring entsprechen
#########################################

	$ftp = Net::FTP->new("192.168.1.1", Debug => 0)
	or die "geht nicht: $@";

	$ftp->login("user", "pass")
	or die "geht nicht login: $@";

	@filesAndSubfolders = $ftp->ls("/");

	foreach $filesAndSubfolder (@filesAndSubfolders)
	{

	@fileinfos = ($filesAndSubfolder,$ftp->mdtm($filesAndSubfolder),$ftp->size($filesAndSubfolder));
	#print $fileinfos[0] . "\n";

     		if (grep {/$searchstring/} $fileinfos[0]  )
        	{
			
                 	$ftp->get($fileinfos[0],$downloaddir . "/" . $fileinfos[0])
                 	or die "$@";
        
		}
#########################################






---------------------------------------------------------------------------------------------------------





#########################################
#Directory erstellen
#########################################
@args = ("$mkdir", "-p", "$downloaddir");
if (system("@args") == 0)
{
	#nothing here...
}
else
{
print "ERROR: Konnte Logdirectory nicht erstellen\n";
exit 1;
}
#########################################





---------------------------------------------------------------------------------------------------------





#########################################
#mysql db auslesen (DBI),mx lookup
#########################################

use strict;
use DBI;
use Net::Nslookup;
use Net::SMTP::Multipart;



use DBI;
my $datenbank = 'data';
my $datenbankhost = 'localhost';
my $datenbankuser = 'roeschu';
my $mydns = 'ns.meindns.com';
my $datenbankpw = 'friss99kiwisdusoumore';
my $resolver = 'ns1.opendns.ch';
my @addrs = nslookup $resolver;
my $host;
my $row;

my $dbh = DBI->connect("DBI:mysql:$datenbank:$datenbankhost","$datenbankuser","$datenbankpw")
or print "Fehler bei der Datenbankverbindung aufgetreten.";


my $sth = $dbh->prepare("SELECT DomainName FROM domains");
$sth->execute or die DBI->errstr;



  while(my (@inhalt) = $sth->fetchrow_array()) 
   { 
        my @mx = nslookup(qtype => "MX", domain => @inhalt[0]);
	sleep(1);

	print @mx[0] . "  " . @inhalt[0] . "\n";

		if (@mx[0] ne $mydns)
		{

			my $smtp = Net::SMTP::Multipart->new("localhost");
  			$smtp->Header(To   => "support\@soumore.com",
                	Subj => "Mailhost: Inaktive Maildomains prüfen: " . @inhalt[0],
                	From => "bla@ls.ch");
  			$smtp->Text("Die Maildomain " . @inhalt[0] . " auf mailhost (postfix) hat einen MX Record welcher nicht mehr auf unsere Server zeigt. Bitte kontrollieren und die Maildomain ggf. 			loeschen");
 			$smtp->End();


		}
	
	 
   } 


$sth->finish;
$dbh->disconnect;


#########################################
